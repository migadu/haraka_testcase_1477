var util   = require('util');
var fs     = require('fs');
var Stream = require('stream').Stream;

var ArrayStream = function () {
    Stream.call(this);

    this.data_lines = [];
    this.data_bytes = 0;
    this.header_pos = 0;
    this.data_marker = 0;
    this.max_mem_bytes = 5;
    this.fs_wstream = null;
    this.fd_wstream = null;
    this.switching  = false;
    this.paused     = false;
    this.readable   = true;
    this.fix_line   = function (line) { return line };
};

util.inherits(ArrayStream, Stream);

// The only thing we get is EventEmitter stuff, and pipe(), so the rest needs implemented:

ArrayStream.prototype.add_data = function (line) {
    var self = this;
    if (this.switching) {
        return setTimeout(100, function () {
            self.add_data(line);
        });
    }
    self.data_bytes += line.length;

    if (self.fs_wstream) {
        return fs.write(self.fd_wstream, line);
        return self.fs_wstream.write(line);
    }
    self.data_lines.push(line);

    // If we exceeded our max_mem_bytes...
    if (self.data_bytes > self.max_mem_bytes) {
        self._switch_to_disk();
    }
}

ArrayStream.prototype._switch_to_disk = function () {
    var self = this;
    // Switch to a writable stream
    this.switching = true;
    console.log("Switching to a disk file!");
    var tmp_path = 'XXX'; // TODO: give a better path
    var fd;
    try {
        fd = fs.openSync(tmp_path, "wx+")
    }
    catch (err) {
        if (/Unknown file open flag/.test(err)) {
            fd = fs.openSync(tmp_path, "w+");
        }
        else {
            throw err;
        }
    }

    fs.writeSync(fd, this.data_lines.join(''));
    this.fd_wstream = fd;
    this.fs_wstream = tmp_path;

    this.switching = false;

    // var fs_wstream;
    
    // try {
    //     fs_wstream = fs.createWriteStream(tmp_path, { flags: 'wx+' });
    // }
    // catch (err) {
    //     if (/Unknown file open flag/.test(err)) {
    //         // Node version too early, skip "x" - insecure though!
    //         fs_wstream = fs.createWriteStream(tmp_path, { flags: 'w+' });
    //     }
    //     else {
    //         this.switching = false;
    //         throw err;
    //     }
    // }

    // fs_wstream.on('error', function (err) {
    //     // Fucked if I know what to do here.
    //     this.switching = false;
    // });

    // fs_wstream.on('open', function (fd) {
    //     self.fd_wstream = fd;
    // })
    // self.on('end', function () {
    //     this.switching = false;
    //     console.log("Disk file switch done!");
    //     self.fs_wstream = fs_wstream;
    // });
    // self.pipe(fs_wstream, { doitanyway: true }); // Not sure this will work!
}

ArrayStream.prototype._read = function () {
    // console.log("read!");
    var self = this;
    if (!self.readable || self.paused) {
        // console.log("Paused");
        return;
    }

    if (this.data_marker >= this.data_lines.length) {
        // got to end
        // console.log("Got to end");
        self.emit('end');
        return;
    }

    // Not sure I *have* to do this on nextTick - but I worried I would
    // block otherwise, and calls to .pause() wouldn't do the right thing
    process.nextTick(function () {
        var line = self.data_lines[self.data_marker];
        self.data_marker++;
        // console.log("emitting: " + line);
        self.emit('data', line);
        self._read();
    });
}

// Don't think this will get called?
ArrayStream.prototype.destroy = function () {
    console.log("destroy called");
    this.readable = false;
}

ArrayStream.prototype.pause = function () {
    this.paused = true;
}

ArrayStream.prototype.resume = function () {
    this.paused = false;
    this._read();
}

ArrayStream.prototype.pipe = function (destination, options) {
    var self = this;
    if (this.switching) {
        return setTimeout(100, function () {
            self.pipe(destination, options);
        });
    }

    if (this.fd_wstream) {
        console.log("Piping from a fs_wstream!");
        fs.close(this.fd_wstream, function () {
            var rstream = fs.createReadStream(self.fs_wstream);
            var fixpipe = new LineFixupFilter (self.fix_line);
            rstream.pipe(fixpipe);
            fixpipe.pipe(destination, options);
        })
        // self.fs_wstream.end();
        // self.fs_wstream.on('close', function () {
        //     var rstream = fs.createReadStream(self.fs_wstream.path);
        //     var fixpipe = new LineFixupFilter (self.fix_line);
        //     rstream.pipe(fixpipe);
        //     fixpipe.pipe(destination, options);
        // })
        return;
    }

    Stream.prototype.pipe.call(this, destination, options);

    this.data_marker = 0;

    this._read();
}

///////////////////////////////////////////////////////////
// Copied from: https://github.com/tim-smart/node-filter

var FilterStream = function FilterStream (writeMethod) {
  var self      = this;
  this.source   = null;
  this.paused   = false;
  this.encoding = null;
  this.writable = true;
  this.readable = true;

  this.on('pipe', function (source) {
    self.setupStream(source);
  });

  if (writeMethod) {
    this.write = writeMethod;
  }
};

util.inherits(FilterStream, Stream);

module.exports = FilterStream;

FilterStream.prototype.setEncoding = function (encoding) {
  this.encoding = encoding;
};

FilterStream.prototype.setupStream = function (source) {
  this.source = source;

  if (this.encoding) {
    source.setEncoding(encoding);
  }
  if (this.paused) {
    source.pause();
  }

  this.writable = true;

  return this;
};

FilterStream.prototype.pause = function () {
  this.paused = true;

  if (this.source) {
    return this.source.pause();
  }

  return true;
};

FilterStream.prototype.resume = function () {
  this.paused = false;

  if (this.source) {
    return this.source.resume();
  }

  return true;
};

FilterStream.prototype.write = function (data) {
  this.emit('data', data);

  return true;
};

FilterStream.prototype.end = function () {
  this.emit('end');
  this.emit('close');
};

var LineFixupFilter = function (filter) {
    if (!filter) {
        filter = function (data) { return data };
    }
    this.filter = filter;
    this.buffer = '';
    FilterStream.call(this);
}

util.inherits(LineFixupFilter, FilterStream);

LineFixupFilter.prototype.write = function (data) {
    this.buffer += data;
    var results;
    while (results = /^([^\n]*\n)/.exec(this.buffer)) {
        var this_line = results[1];
        this.buffer = this.buffer.slice(this_line.length);
        var out = this.filter(this_line);
        console.log("Emitting: " + out);
        this.emit('data', this.filter(this_line));
    }
}

LineFixupFilter.prototype.end = function () {
    if (this.buffer.length) {
        this.emit('data', this.buffer);
    }
    this.buffer = '';
    FilterStream.prototype.end.call(this);
}

// Test...

var as = new ArrayStream();
as.add_data("Foo\nBar\n");
as.add_data("Baz\n");

var p = new LineFixupFilter (function (data) { return data.replace(/^/m, '> ')});

as.pipe(p);
p.pipe(fs.createWriteStream("/tmp/footest"));
